% Copyright 2018 Google Inc.
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%      http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.

%%% script AUTHOR: Paul Crowley, Eric Biggers%%%
%%% script TITLE: {HBSH} and {HPolyNHC}: length-preserving encryption for entry-level processors%%%

\RequirePackage{etoolbox}
\newtoggle{iacr}
\input{work/toggle.tex}
\iftoggle{iacr}{
    \documentclass[journal=tosc,preprint,floatrow,submission]{iacrtrans}
}{ % iacr

    \documentclass[letterpaper,luatex,11pt]{article}

    \usepackage{fontspec}
    \setmainfont{TeX Gyre Pagella}
    \setsansfont{TeX Gyre Heros}
    \setmathrm{Latin Modern Roman}
    \defaultfontfeatures{}
    \setmonofont{TeX Gyre Cursor}[Ligatures={NoCommon,NoRequired,NoContextual},Scale=0.9]

    \usepackage[hmargin=4cm,vmargin=3cm,nohead]{geometry}
    \usepackage{parskip}
    \usepackage[style]{abstract}
    \usepackage{titling}
    \usepackage{sectsty}
    \usepackage{authblk}
    \usepackage{floatrow}
    \usepackage[svgnames]{xcolor}
    \usepackage[breaklinks,colorlinks,urlcolor=DarkBlue,linkcolor=DarkRed,citecolor=DarkGreen]{hyperref}

    \pretitle{\begin{center}\LARGE\bfseries\sffamily} % sf title
    \renewcommand{\abstitlestyle}{\sffamily\bfseries\centering} % sf abstract
    \allsectionsfont{\sffamily} % sf sections

    \raggedright
    \raggedbottom

} % non-iacr

\usepackage[style=alphabetic,backend=biber]{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[logic,probability,advantage,adversary,landau]{cryptocode}
\usepackage{algpseudocode}

\usepackage{tikz}
\usepackage{makecell}

\usepackage{longtable}

\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\encode}{encode}
\DeclareMathOperator{\XChaCha12}{XChaCha12}
\DeclareMathOperator{\HBSH}{HBSH}
\DeclareMathOperator{\Polydjb}{Poly1305}
\DeclareMathOperator{\NHPoly}{NHPoly1305}

\DeclareMathOperator{\NH}{NH}
\DeclareMathOperator{\intify}{int}
\DeclareMathOperator{\fromint}{fromint}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\addbibresource{bib.bib}

\usetikzlibrary{positioning}
\usetikzlibrary{groupops}

\newcommand*{\arrowoplus}{\leftarrow\mkern-12mu\oplus}
\newcommand*{\xprm}[2]{\textsf{\ref*{#1}-#2}}
\newcommand*{\xprmtitle}[2]{\textbf{\xprm{#1}{#2}}}
\newcommand*{\calE}{\mathcal{E}}
\newcommand*{\calD}{\mathcal{D}}
\newcommand*{\barE}{\overline{\calE}}
\newcommand*{\barD}{\overline{\calD}}

\title{{HBSH} and {HPolyNHC}: length-preserving encryption for entry-level processors}
\iftoggle{iacr}{
    \author{Paul~Crowley \and Eric~Biggers}
    \institute{Google LLC \\ \email[paulcrowley@google.com,ebiggers@google.com]{{paulcrowley,ebiggers}@google.com}}
}{ % iacr
    \author{Paul~Crowley}
    \author{Eric~Biggers}
    \affil{Google LLC}
} % non-iacr

\tikzset{cbox/.style={
        rectangle,
        thick,
        draw,
        minimum height=1cm,
        text centered,
        anchor=center,
        rounded corners=2pt,
    }
}

\begin{document}
\maketitle
\iftoggle{iacr}{
    \keywords{strong pseudorandom permutation \and
        variable input length \and
        tweakable encryption \and
        disk encryption}
}{ % iacr
} % non-iacr

\begin{abstract}
    We present HBSH, a simple construction for tweakable length-preserving encryption which
    directly supports the fastest options for hashing and stream encryption for processors
    without AES or other crypto instructions, with a provable
    quadratic advantage bound. Our composition HPolyNHC uses NH, Poly1305, XChaCha12,
    and a single AES invocation; on an ARM Cortex-A7 processor, HPolyNHC decrypts
    4096-byte messages at 11.8 cycles per byte, five times faster than
    AES-256-XTS, with a constant-time implementation.
\iftoggle{iacr}{
}{

    This paper: \url{https://ia.cr/2018/720} \\
    Source: \url{https://github.com/google/hpolyc} \\
    Email: \href{mailto:paulcrowley@google.com,ebiggers@google.com}{\{paulcrowley,ebiggers\}@google.com}
}
\end{abstract}

\section{Introduction}
Two aspects of disk encryption make it a challenge for cryptography.  First,
performance is critical; every extra cycle is a worse user experience, and on a mobile device
a reduced battery life.  Second, the ciphertext can be no larger than the plaintext: a sector-sized
read or write to the filesystem must mean a sector-sized read or write to the underlying device,
or performance will again suffer greatly
(as well as, in the case of writes to flash memory, the life of the device).
Nonce reuse is inevitable as there is nowhere to store a varying nonce, and there is no space
for a MAC; thus standard constructions like AES-GCM are not an option and standard notions
of semantic security are unachievable.  The best that can be done under the circumstances is
a ``tweakable super-pseudorandom permutation'': an attacker with access to both encryption
and decryption functions who can choose tweak and plaintext/ciphertext freely is unable to
distinguish it from a family of independent random permutations.

\subsection{History}

Hasty Pudding Cipher~\cite{hpc} was a variable-input-length primitive presented to the AES contest.
A key innovation
was the idea of a ``spice'', which was later formalized as a ``tweak'' in~\cite{tweakable}.
Another tweakable large-block primitive was Mercy~\cite{mercy},
cryptanalyzed in~\cite{mercycryptanalysis}.

\cite{luby-rackoff} (see also~\cite{maurer-luby-rackoff,ppdes})
shows how to construct a pseudorandom permutation using a three-round Feistel
network of pseudorandom functions;
proves that this is not a secure super-pseudorandom permutation (where the adversary
has access to decryption as well as encryption) and that four rounds suffice for this aim.
BEAR and LION~\cite{bearlion} apply this result to an unbalanced Feistel network to build a
large-block cipher from a hash function and a stream cipher (see also BEAST~\cite{beast}).

\cite{fasterlr} shows that a universal function (here called a ``difference concentrator'')
suffices for the first round, which~\cite{NaorReingold} extends to four-round function
to build a super-pseudorandom permutation.

More recently, proposals in this space have focused on the use of
block ciphers. VIL mode~\cite{brvil} is a CBC-MAC based two-pass variable-input-length construction which
is a PRP but not an SPRP. CMC mode~\cite{cmc} is a true SPRP using two passes of the block cipher;
EME mode~\cite{eme} is similar but parallelizable, while
EME* mode~\cite{emestar} extends EME mode to handle blocks that are not a multiple of the block
cipher size. PEP~\cite{pep}, TET~\cite{tet}, and HEH~\cite{heh} have a mixing layer either side of
an ECB layer.

XCB~\cite{xcb} is a block-cipher based unbalanced three-round Feistel network with an
$\epsilon$-almost-XOR-universal hash function for the first and third rounds
(``hash-XOR-hash''),
which uses block
cipher invocations on the narrow side of the network to ensure that the network is an SPRP, rather
than just a PRP; it also introduces a tweak.
HCTR~\cite{hctr,hctr2}, HCH~\cite{hch}, and HMC~\cite{hmc} reduce this to a single
block cipher invocation within the Feistel network.
These proposals require
either two AES invocations, or an AES invocation and two $\GF(2^{128})$ multiplications,
per 128 bits of input.

\subsection{Our contribution}
On the ARM architecture, the ARMv8 Cryptography Extensions include instructions that make
AES and $\GF(2^{128})$ multiplications much more efficient. However,
smartphones designed for developing markets
often use lower-end processors which
don't support these extensions, and as a result there is no existing SPRP construction which performs
acceptably on them.

On such platforms stream ciphers such as ChaCha12~\cite{chacha} significantly
outperform block ciphers in cycles per byte, especially with constant-time implementations.
Similarly, absent specific processor support, hash functions such as NH~\cite{nh} and
Poly1305 hash~\cite{poly1305} will be much faster
than a $\GF(2^{128})$ polynomial hash. Since these are the operations that act on the bulk of
the data in a disk-sector-sized block, a hash-XOR-hash
mode of operation relying on them should achieve
much improved performance on such platforms.

To this end, we present the HBSH (hash, block cipher, stream cipher, hash)
construction, which generalizes over constructions such as
HCTR and HCH by taking an $\epsilon$-almost-XOR-universal hash functions and a stream cipher
as components. More specifically, we propose HPolyNHC,
which uses a combination of NH and Poly1305 for the hashing, XChaCha12 for the stream cipher, and
AES for the single blockcipher application. HPolyNHC:
\begin{itemize}
    \item is a tweakable, variable-input-length, super-pseudorandom permutation
    \item has a security bound quadratic in the number of queries and linear in message length
    \item is key agile
    \item is highly parallelizable
    \item needs only three passes over the bulk of the data, or
        two if the XOR is combined with the second hash.
\end{itemize}

Without special cases or extra setup, HPolyNHC handles:
\begin{itemize}
    \item any message and tweak lengths within the allowed range,
    \item varying message and tweak lengths for the same keys.
\end{itemize}

The proof of security differs from other hash-XOR-hash modes in three ways. First,
Poly1305 hash is not XOR universal, but universal over $\mathbb{Z}/2^{128}\mathbb{Z}$,
so for XOR of hash values we substitute addition and subtraction in the appropriate group.
Second, using the XSalsa20 construction~\cite{xsalsa}, we can directly
build a stream cipher which takes a 192-bit nonce to generate a stream, simplifying
the second Feistel operation and associated proof, as well as subkey generation.
Finally, Poly1305 hash has a much weaker security bound than the $\GF(2^{128})$ polynomial hash;
the proof is shaped around ensuring we pay the smallest multiple of this cost we can.

\section{Specification}
HBSH divides the input into a right-hand block of $n$ bits and a left-hand block with
the remainder of the input, and uses a stream cipher $S$ and an
$\epsilon$-almost-$\Delta$-universal
function $H$ to build an unbalanced Feistel network that includes one invocation of an
$n$-bit block cipher $E$.

\begin{figure}
    \begin{floatrow}
        \ffigbox{
            \input{finalfig.tex}
        }{
            \caption{HBSH}\label{finalfig}
        }
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{HBSHEncrypt}{$T,P$}
                \State $P_L || P_R \gets P$
                \State $P_M \gets P_R \boxplus H_{K_H}(T, P_L)$
                \State $C_M \gets E_{K_E}(P_M)$
                \State $C_L \gets P_L \arrowoplus S_{K_S}(C_M)$
                \State $C_R \gets C_M \boxminus H_{K_H}(T, C_L)$
                \State $C \gets C_L || C_R$
                \State \textbf{return} $C$
                \EndProcedure
            \end{algorithmic}
            \begin{algorithmic}[0]
                \Procedure{HBSHDecrypt}{$T,C$}
                \State $C_L || C_R \gets C$
                \State $C_M \gets C_R \boxplus H_{K_H}(T, C_L)$
                \State $P_L \gets C_L \arrowoplus S_{K_S}(C_M)$
                \State $P_M \gets E_{K_E}^{-1}(C_M)$
                \State $P_R \gets P_M \boxminus H_{K_H}(T, P_L)$
                \State $P \gets P_L || P_R$
                \State \textbf{return} $P$
                \EndProcedure
            \end{algorithmic}
        }{\caption{Pseudocode for HBSH}\label{pseudocode}}
    \end{floatrow}
\end{figure}

We derive ciphertext $C$ from plaintext $P$ and tweak $T$ as shown in \autoref{pseudocode}.
$||$ represents concatenation, and $P_R$, $P_M$, $C_M$, $C_R$ are $n$ bits long.
$\boxplus$ represents addition in a group which depends
on the hash function, and $\boxminus$ subtraction. $X \arrowoplus Y$
is the bitwise XOR of $X$ with the first $|X|$ bits of $Y$.
Partial application is implicit; if we define $f: A \times B \rightarrow C$ and
$a \in A$ then $f_a: B \rightarrow C$ and if $f_a^{-1}$ exists then $f_a^{-1}(f_a(b)) = b$.

\subsection{Block cipher}
The 128-bit block cipher $E: \mathcal{K}_E \times \{0,1\}^n \rightarrow \{0,1\}^n$
is only invoked once no matter the size of the input, so for disk sector-sized inputs
its performance isn't critical. HPolyNHC uses AES-256~\cite{AES}.

\subsection{Stream cipher}
$S: \mathcal{K}_S \times (\lambda \cup \{0,1\}^n) \rightarrow \{0,1\}^{l_S}$
is a stream cipher which takes a nonce and produces a long random stream. In normal use
the nonce is an $n$-bit string, but for key derivation we use the empty string $\lambda$, which
is distinct from all $n$-bit strings.

The ChaCha12 stream cipher~\cite{chacha}
defines a PRF which takes a 64-bit (or 96-bit~\cite{RFC7539})
nonce and an integer stream offset and returns a 512-bit output, and
concatenates successive outputs to define a function from key and nonce to stream
in a seekable way.
Since $C_M$ is larger than the ChaCha12 nonce size, HPolyNHC uses the
XSalsa20 construction~\cite{xsalsa} initially proposed for Salsa20~\cite{salsa20,salsa812}
to construct XChaCha12 which extends the nonce to 192 bits
(as libsodium~\cite{xchacha20}
and Monocypher~\cite{monocypher} do
with ChaCha20). From here we construct a function that takes a variable-length nonce of up to
191 bits by padding with a 1 followed by zeroes:
$S_{K_S}(C_M) = \XChaCha12_{K_S}(C_M || 1 || 0^{191-|C_M|})$. For a
given key and nonce, XChaCha12 produces $l_S = 2^{73}$ bits of output; we
therefore require that the HPolyNHC plaintext length be within the bounds
$n \leq |P| \leq l_S + n$.

\subsection{Hash}
$H_{K_H}$ is a $\epsilon$-almost-$\Delta$-universal ($\epsilon$A$\Delta$U) function over a group
defined on $n$-bit strings. The fastest such hash functions are based on NH, but NH generally
requires a second hashing stage. For HPolyNHC we combine NH with Poly1305, and the group for
$\boxplus$ and $\boxminus$ is $\mathbb{Z}/2^{128}\mathbb{Z}$; we defer the exact specification
of this function to \autoref{NHPoly1305}.

\subsection{Key derivation}\label{keyderivation}
HBSH derives $K_H$ and $K_E$ from $K_S$ using a zero-length nonce:
$K_E || K_H \ldots = S_{K_S}(\lambda)$.

\section{Design}
Any secure PRP must have a pass that reads all of the plaintext, followed by a pass that modifies
it all. A secure SPRP must have the same property in the reverse direction;
a three-pass structure therefore seems natural.
$\epsilon$A$\Delta$U functions are the fastest options for reading the plaintext in a
cryptographically useful way, and stream ciphers are the fastest options for modifying it.
$\epsilon$A$\Delta$Us
are typically much faster than stream ciphers, and so the hash-XOR-hash structure emerges as
the best option for performance. This structure also has the advantage that it naturally handles
blocks in non-round sizes; many large-block modes need extra wrinkles akin to ciphertext stealing
to handle the case where the large-block size is not
a multiple of the block size of the underlying primitive.

\cite{luby-rackoff} observes that a three-round Feistel network cannot by itself be a secure SPRP;
a simple attack with two plaintexts and one ciphertext distinguishes it. A single block cipher call
in the narrow part of the unbalanced network suffices to frustrate this attack; the
larger the block, the smaller the relative cost of this call.
Compared to HCTR~\cite{hctr} or HCH~\cite{hch}, we sacrifice
symmetry of encryption with decryption in return for
the ability to run the block cipher and stream cipher in parallel when decrypting.
For disk encryption, decryption performance matters most:
reads are more frequent than writes, and reads generally affect user-perceived latency, while
operating systems can usually perform writes asynchronously in the background.

It's unusual for a construction to require three distinct building blocks.
More commonly, a hash-XOR-hash mode will use a block cipher both on the narrow side of the
block, and to build the stream cipher in the XOR phase (eg using CTR mode~\cite{ctr}).
Using XChaCha12 in place of a block cipher affords a significant increase in performance;
however it cannot easily be substituted in the narrow side of the cipher.
\cite{sarkar1,sarkar2,sarkar3,sarkar4} use only an $\epsilon$AXU function
and a stream cipher, and build a hash-XOR-hash SPRP
with a construction that uses a four-round Feistel network over the non-bulk side of the data
broken into two halves. However if we were to build this using XChaCha12,
such a construction would require four extra invocations of ChaCha per block, which would be
a much greater cost than one block cipher invocation.

HBSH does not consider an attack model in which derived keys are presented as input.
Length-preserving encryption
which is KDM-secure in the sense of~\cite{kdm} is impossible, since it is trivial for the
attacker to submit a query with a $g$-function
that constructs a plaintext whose ciphertext is all zeroes.
Whether there is a notion of KDM-security that can be
applied in this domain is an open problem. Users must take care to protect the keys from being
included in the input.

The main cost of a new key is the call to XChaCha12 to calculate the 336 bytes of subkey needed,
most of which is NH's 304-byte key. Another cost is the AES key schedule;
if the hash is to be calculated in parallel, it can also
be useful to cache powers of the hash key.
ChaCha12 has no key schedule and makes no use of
precomputation; XChaCha12 has a ``nonce scheduling'' step that
must be called once to compute subkeys and once for each HPolyNHC encryption or decryption.
The first 16-byte block consumed by Poly1305 contains the tweak and hash lengths; where
these are constant, the work of consuming these can be cached,
saving one $\mathbb{Z}/(2^{130}-5)\mathbb{Z}$ multiplication (the core operation of Poly1305).
Otherwise no extra work needs to be done for differing message or tweak lengths, unless
new powers of the hash key are needed for parallelism.

NH, Poly1305 and ChaCha12 are designed such that the most natural fast implementations are
constant-time and free from data-dependent lookups. So long as the block cipher implementation
also has these properties, HPolyNHC will inherit security against
this class of side-channel attacks.

NH, Poly1305 and ChaCha12 are highly parallelizable.
The stream cipher and second hash stages can also be run in combination for a total
of two passes over the bulk of the data, unlike a mode such as HEH~\cite{heh}
which requires at least three.
We put the ``special'' block on the right so that in typical uses the bulk encryption has
the best alignment for fast operations.

\section{Performance}

In \autoref{performance} we
show performance on an ARM \mbox{Cortex-A7}
processor in the Snapdragon 400 chipset running at \mbox{1.19 GHz}.  This
processor supports the NEON vector instruction set, but not the ARM cryptographic
extensions; it is used in many smartphones and smartwatches, especially low-end
or older devices, and is representative of the kind of platform we mean to target.
Where the figures are within 2\%, a single row is shown for both encryption and decryption.

\begin{table}
    \caption{Performance on ARM Cortex-A7}
    \label{performance}
    \centering
    \begin{tabular}{lrr}
        Algorithm &
            \makecell{Cycles per byte \\ (4096-byte sectors)} &
            \makecell{Cycles per byte \\ (512-byte sectors)} \\
    \hline
    \input{work/performance.tex}
    \end{tabular}
\end{table}

We have prioritized performance on 4096-byte messages, but we also tested 512-byte messages.
512-byte disk sectors were the standard until the introduction of Advanced Format in 2010;
modern large hard drives and flash drives now use 4096-byte sectors.
On Linux, 4096 bytes is the standard page size, the standard allocation unit size for filesystems,
and the granularity of \textit{fscrypt} file-based encryption, while
\mbox{\textit{dm-crypt}} full-disk encryption has recently been updated
to support this size.

For comparison we evaluate against various block ciphers in XTS mode~\cite{xts}:
AES\mbox~\cite{AES}, Speck~\cite{speck1,speck2,speck3}, NOEKEON~\cite{noekeon},
and XTEA~\cite{xtea}. We also include the performance of ChaCha, NH,
and Poly1305 by themselves for reference.
We used the fastest constant-time implementation of each algorithm we were able
to find or write for the platform; see \autoref{implementation}.  In every case
except \texttt{aes\_ti.c},
the performance-critical parts were written in assembly language using NEON
instructions.

\begin{table}
    \caption{Implementations}
    \label{implementation}
    \centering
    \begin{tabular}{llp{7cm}}
        Algorithm & Source & Notes \\
    \hline
    ChaCha & Linux v4.17 & \texttt{chacha20-neon-core.S}, modified to support ChaCha8 and ChaCha12 \\
    Poly1305 & OpenSSL 1.1.0h & \texttt{poly1305-armv4.S}, modified to allow key
    powers to be computed just once per key \\
    \mbox{AES} & Linux v4.17 & \texttt{aes\_ti.c}, used once per message in HPolyNHC \\
    \mbox{AES-XTS} & Linux v4.17 & \texttt{aes-neonbs-core.S} (bit-sliced) \\
    \mbox{Speck128/256-XTS} & Linux v4.17 & \texttt{speck-neon-core.S} \\
    \mbox{NOEKEON-XTS} & ours & \\
    \mbox{XTEA-XTS} & ours & \\
    \end{tabular}
\end{table}

HPolyNHC is the only algorithm in \autoref{performance} which is a tweakable
super-pseudorandom permutation over the entire sector.  We expect any AES-based
construction to that end to be significantly slower than \mbox{AES-XTS}.
HPolyNHC has a larger per-message overhead than XTS; both require one
extra block cipher invocation per message, but HPolyNHC must also perform one extra
ChaCha permutation for the XChaCha construction and one extra Poly1305 block for the tweak.

We conclude that for 4096-byte sectors, \mbox{HPolyNHC-XChaCha12-AES} can perform
significantly better than an aggressively designed block cipher (\mbox{Speck128/256}) in XTS mode.
Efficient implementations of NH, Poly1305 and ChaCha are available for many
platforms, as these algorithms are well-suited for implementation with either
general-purpose scalar instructions or with general-purpose vector instructions
such as NEON or AVX2.
For a greater margin of security at a slower speed, ChaCha20 can
be used instead of ChaCha12; the same stream cipher
must be used for key derivation as for the Feistel function.

\section{Security reduction}
HBSH is a tweakable, variable-input-length, secure pseudorandom permutation: an attacker
succeeds if they distinguish it from a family of independent random permutations indexed by
input length and tweak, given access to both encryption and decryption oracles.

Given keys $K_S$, $K_H$, $K_E$, HBSH is the conjugation of an inner transform by an outer:
\begin{align*}
    \HBSH:
    \{0,1\}^* &\times \{0,1\}^l \times \{0,1\}^n \rightarrow \{0,1\}^l \times \{0,1\}^n \\
    \HBSH_{T} &= \phi^{-1}_{K_H, T}
    \circ \theta_{E_{K_E}, S_{K_S}} \circ \phi_{K_H, T} \\
    \theta_{e, s}(P_L, P_M) &= (P_L \arrowoplus s(e(P_M)), e(P_M)) \\
    \phi_{K_H, T}(L, R) &= (L, R \boxplus H_{K_H}(T, L)) \\
    \phi^{-1}_{K_H, T}(L, R) &= (L, R \boxminus H_{K_H}(T, L))
\end{align*}

These are families of length-preserving functions parameterized by the length
$|P_L| = |L| = |C_L| = l \in \mathbb{N}$;
for notational convenience we leave this parameter implicit.

We prove a security bound for HBSH in three stages:
\begin{itemize}
    \item we consider distinguishers for the inner construction $\theta$ in an
    attack model which forbids ``inner collisions'' in queries
    \item we prove a bound on the probability of an attacker causing an inner collision
    \item we put this together to bound the success probability of a distinguisher against
    HBSH.
\end{itemize}

At each stage, we consider an attacker \(\adv^{\calE, \calD}\) who makes $q$ queries
to oracles for
two length-preserving function families which take a tweak; the attacker is always free to vary
the length of input and tweak.

\begin{align*}
\calE, \calD:
\{0,1\}^* &\times \{0,1\}^l \times \{0,1\}^n \rightarrow \{0,1\}^l \times \{0,1\}^n \\
(C_L, C_R) &\leftarrow \calE_T(P_L, P_R) \\
(P_L, P_R) &\leftarrow \calD_T(C_L, C_R) \\
\end{align*}

\subsection{Inner part}\label{innerpart}

We consider an attacker trying to distinguish an idealized $\theta$ from a
pair of families of random length-preserving functions,
but we forbid the attacker from causing ``inner collisions'':
having made either of the queries: \label{constraints}
\begin{itemize}
    \item $(C_L, C_M) \leftarrow \calE_T(P_L, P_M)$
    \item $(P_L, P_M) \leftarrow \calD_T(C_L, C_M)$
\end{itemize}
both of the queries below are subsequently disallowed:
\begin{itemize}
    \item $\calE_\cdotp(\cdotp, P_M)$
    \item $\calD_\cdotp(\cdotp, C_M)$
\end{itemize}
where $\cdotp$ represents any value. However assuming $C_M \neq P_M$, this does not disallow
subsequent queries of the form $\calD_\cdotp(\cdotp, P_M)$ or $\calE_\cdotp(\cdotp, C_M)$
and it's important to consider such queries at each step below. We write
$P_M$/$C_M$ for the second argument and result to match notation used for $\theta$ elsewhere.
At this stage, we consider computationally unbounded attackers; we'll consider resource-bounded
attackers in~\autoref{composition}.

In what follows we use a standard concrete security hybrid argument per~\cite{concrete,games}:
for a fixed class of attacker, distinguishing advantage obeys the triangle inequality and
forms a pseudometric space. We consider a
sequence of experiments, bound the distingushing advantage between successive
experiments, and thereby
prove an advantage bound for a distinguisher between the first and the last experiment
which is the sum of the advantage bound between each successive experiment.

\xprmtitle{innerpart}{randinner}: $\calE$ and $\calD$ are families of
random functions. Since by our constraints above every query to each
is distinct, every output of the
appropriate length is equally likely. Wherever we specify that an experiment uses multiple random
functions, those functions are independent unless stated otherwise.

\xprmtitle{innerpart}{notweak}: Ignore the tweak: let
$\barE, \barD$ be random length-preserving function families from
$\{0,1\}^l \times \{0,1\}^n \rightarrow \{0,1\}^l \times \{0,1\}^n$
and let $\calE_T = \barE$ and $\calD_T = \barD$ for all $T$.
Since by the above constraints, for each random function the second argument in every query
is still always distinct, every output of the appropriate length is equally
likely as before, and this is indistinguishable from \xprm{innerpart}{randinner}.

\xprmtitle{innerpart}{doublerf}: Use a Feistel network in which the stream cipher
nonce includes both $P_M$ and $C_M$.
\begin{itemize}
    \item $F_S: \{0,1\}^{2n} \rightarrow \{0,1\}^{l_S}$ is a random
    function
    \item $F_E, F_D: \{0,1\}^n \rightarrow \{0,1\}^n$ are random functions
    \item $\calE_T(P_L, P_M) = (P_L \arrowoplus F_S(P_M || F_E(P_M)), F_E(P_M))$
    \item $\calD_T(C_L, C_M) = (C_L \arrowoplus F_S(F_D(C_M) || C_M), F_D(C_M))$
\end{itemize}
Again, the constraints above ensure that for each random function,
every query is distinct,
every output of the appropriate length is equally
likely as before, and this is indistinguishable from
\xprm{innerpart}{notweak} and \xprm{innerpart}{randinner}.

\xprmtitle{innerpart}{rpswitch}: Substitute a random permutation for the pair of random functions.
\begin{itemize}
    \item $F_S: \{0,1\}^{2n} \rightarrow \{0,1\}^{l_S}$ is a random function as before
    \item $\pi: \{0,1\}^n \rightarrow \{0,1\}^n$ is a random permutation
    \item $\calE_T(P_L, P_M) = (P_L \arrowoplus F_S(P_M || \pi(P_M)), \pi(P_M))$
    \item $\calD_T(C_L, C_M) = (C_L \arrowoplus F_S(\pi^{-1}(C_M) || C_M), \pi^{-1}(C_M))$
    ie $\calD_T = \calE_T^{-1}$
\end{itemize}
The constraints above rule out ``pointless'' queries on $\pi$, so per section C of~\cite{cmc}
the advantage in distinguishing this from \xprm{innerpart}{doublerf} is at most
$2^{-n}\binom{q}{2}$.

\xprmtitle{innerpart}{halfrf}: Replace the two-argument $F_S$ with
a single-argument version which uses only $C_M$.
\begin{itemize}
    \item $F_S: \{0,1\}^n \rightarrow \{0,1\}^{l_S}$ is a random function
    \item $\pi: \{0,1\}^n \rightarrow \{0,1\}^n$ is a random permutation as before
    \item $\calE_T(P_L, P_M) = (P_L \arrowoplus F_S(\pi(P_M)), \pi(P_M))$
    ie $\calE_T = \theta_{\pi, F_S}$
    \item $\calD_T(C_L, C_M) = (C_L \arrowoplus F_S(C_M), \pi^{-1}(C_M))$
    ie $\calD_T = \theta_{\pi, F_S}^{-1}$
\end{itemize}
Since $\pi$ is a permutation,
for any pair of queries $C_M = C_M'$ if and only if $P_M = P_M'$.
This is therefore indistinguishable from \xprm{innerpart}{rpswitch}.
This is a small upside to HBSH's asymmetry: if a symmetrical
construction such as $F_S(P_M \oplus \pi(P_M))$ were used here instead, it would be
distinguishable with advantage $2^{-n}\binom{q}{2}$.

Summing these distances, with these constraints the advantage distinguishing between
\xprm{innerpart}{randinner} and \xprm{innerpart}{halfrf} is at most
$2^{-n}\binom{q}{2}$.

\subsection{Collision finding}\label{collision}
In what follows, we assume that $H$ is $\epsilon$-almost-$\Delta$-universal:
for any $g \in \{0,1\}^n$ and
any two distinct messages $(T, m) \neq (T', m')$
the number of keys $K_H \in \mathcal{K}_H$
such that $H_{K_H}(T, m) \boxminus H_{K_H}(T', m') = g$ is at most $\epsilon|\mathcal{K}_H|$: ie
for a random
$K_H \xleftarrow{\$} \mathcal{K}_H$ we have for any $(g, T, m) \neq (g', T', m')$ that
$\prob{H_{K_H}(T, m) \boxplus g = H_{K_H}(T', m') \boxplus g'} \leq \epsilon$.
Since HPolyNHC builds $H_{K_H}$ using a polynomial hash, the value of $\epsilon$ will depend
on the maximum length of the message and tweak we allow the attacker to query for, as
discussed in \autoref{NHPoly1305}.
We use this to bound the probability that the attacker will cause an
``inner collision''---a query to the inner part which doesn't meet the constraints described
in \autoref{constraints}.

From here on, we forbid only ``pointless queries'': after either of the queries
$(C_L, C_R) \leftarrow \calE_T(P_L, P_R)$ or $(P_L, P_R) \leftarrow \calD_T(C_L, C_R)$,
both the subsequent queries
$\calE_T(P_L, P_R)$ and $\calD_T(C_L, C_R)$ would be forbidden. Again, we consider a
computationally unbounded attacker.

A hash key $K_H \xleftarrow{\$} \mathcal{K}_H$ is chosen at random, and for each query we define
\begin{itemize}
    \item $P_M = P_R \boxplus H_{K_H}(T, P_L)$
    \item $C_M = C_R \boxplus H_{K_H}(T, C_L)$
\end{itemize}

For query $1 \leq i \leq q$, we'll use superscripts to refer to the variables for that query, eg
$P_M^i$, $C_M^i$. The attacker wins if there exists $i < j \leq q$ such that
either
\begin{itemize}
    \item $j$ is a plaintext query (a query to $\calE$) and $P_M^i = P_M^j$ or
    \item $j$ is a ciphertext query (a query to $\calD$) and $C_M^i = C_M^j$.
\end{itemize}
We do not consider a query such that $C_M^i = P_M^j$ (or vice versa) a win.

Here we are considering not distingushing probability but success probability; we
show a bound on success probability for the first experiment, and for each subsequent experiment
we bound the increase in success probability over the previous experiment.

\xprmtitle{collision}{keyend}: Choose responses fairly at random of the appropriate length;
once all $q$ queries are complete, choose the hash key and see if the attacker succeeded.

If query $j$ is a plaintext query, the attacker knows the query and result
for all $i < j$, and can choose plaintext values to maximize the probability of success.
If $T^i, P_L^i = T^j, P_L^j$ then the hashes will be the same, and since pointless
queries are forbidden we have that $P_R^i \neq P_R^j$ and therefore that
$P_M^i \neq P_M^j$. Otherwise by the $\epsilon$A$\Delta$U property,
$\prob{P_M^i = P_M^j} \leq \epsilon$. The same success bound holds for a ciphertext query.
The overall probability of success
is at most the sum of the probability of success for each pair:
$\epsilon\binom{q}{2}$.

Note that we don't assume that probabilities are independent here;
for any events $A$, $B$ we have that $\prob{A \vee B} \leq \prob{A} + \prob{B}$, with
equality if $A$, $B$ are disjoint. Here distjointness means that the attacker can
choose queries such that no key causes more than one pair to succeed, making full use of
the assumption on each query that previous queries have failed.

\xprmtitle{collision}{keystart}: As with \xprm{collision}{keyend}, but
choose the key at the start of the experiment. This
does not change the probability of success.

\xprmtitle{collision}{earlystop}: As with \xprm{collision}{keystart}, but
end the experiment as soon as the attacker succeeds.
This doesn't change the success probability.

\xprmtitle{collision}{randomfuncs}: Use random function families for $\calE$,
$\calD$. Since we forbid pointless queries,
all responses of the appropriate length are equally likely as before,
and this doesn't change the success probability.

\xprmtitle{collision}{randinner}: Use random function families for $\calE'$, $\calD'$, and define
\begin{itemize}
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \calE_T' \circ \phi_{K_H, T}$
    \item $\calD_T = \phi^{-1}_{K_H, T} \circ \calD_T' \circ \phi_{K_H, T}$
\end{itemize}

Since a random function composed with a bijective function is a random function,
this doesn't change the success probability, which remains at most
$\epsilon\binom{q}{2}$.

\xprmtitle{collision}{halfrf}: The middle part of the sandwich is now a pair of random functions,
as per the first experiment in \autoref{innerpart}, \xprm{innerpart}{randinner}.
Substitute this with the last experiment, \xprm{innerpart}{halfrf}:

\begin{itemize}
    \item $F_S: \{0,1\}^n \rightarrow \{0,1\}^{l_S}$ is a random function
    \item $\pi: \{0,1\}^n \rightarrow \{0,1\}^n$ is a random permutation
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{\pi, F_S} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1} = \phi^{-1}_{K_H, T} \circ \theta_{\pi, F_S}^{-1} \circ \phi_{K_H, T}$
\end{itemize}

Given any attacker for this experiment,
we construct a distinguisher between \xprm{innerpart}{randinner} and \xprm{innerpart}{halfrf} as
follows: we choose a random $K_H$, and use our oracle for the inner part as $\theta$.
We report 1 if the attacker succeeds in generating an inner collision.
We stop the experiment early if the attacker succeeds, and any query in which the attacker
does not succeed is one that obeys the query bounds of \autoref{innerpart}.
Therefore, the difference in success probability
between \xprm{collision}{randinner} and \xprm{collision}{halfrf}
for these two outer experiments can be no more than
the advantage bound of $2^{-n}\binom{q}{2}$
established in~\autoref{innerpart} for distinguishing between
\xprm{innerpart}{randinner} and \xprm{innerpart}{halfrf}.
The success
probability for this final experiment is therefore at most
$(\epsilon + 2^{-n})\binom{q}{2}$.

\subsection{Composition}\label{composition}

Finally we put these pieces together to bound the advantage of distinguishing HBSH from
a family of random permutations. As before, the attacker can make encryption and decryption queries
but ``pointless'' queries are forbidden; in addition, the attacker is constrained by a time
bound $t$. We start with this experiment:

\xprmtitle{composition}{permutation}: For all lengths and all $T$, $\calE_T$ is a random permutation,
and $\calD_T = \calE_T^{-1}$. The security of a variable-length tweakable SPRP is defined by
the advantage bound in distinguishing it from this experiment.

\xprmtitle{composition}{randomfuncs}: $\calE$ and $\calD$ are
families of random functions.
Since pointless queries are forbidden, the advantage in distinguishing this from
\xprm{composition}{permutation} is at most $2^{-|P|}\binom{q}{2} \leq 2^{-n}\binom{q}{2}$
per section C of~\cite{cmc}.

\xprmtitle{composition}{randinner}: $\calE'$ and $\calD'$ are families of random functions.
Choose a hash key $K_H \xleftarrow{\$} \mathcal{K}_H$,
and conjugate the random functions by Feistel calls to the hash function:

\begin{itemize}
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \calE_T' \circ \phi_{K_H, T}$
    \item $\calD_T = \phi^{-1}_{K_H, T} \circ \calD_T' \circ \phi_{K_H, T}$
\end{itemize}

as per the step from \xprm{collision}{randomfuncs}
to \xprm{collision}{randinner}.
Since a random function composed with a bijective function is a random function,
this is indistinguishable from \xprm{composition}{randomfuncs}.

\xprmtitle{composition}{halfrf}: Substitute \xprm{innerpart}{halfrf} for \xprm{innerpart}{randinner}.
\begin{itemize}
    \item $K_H \xleftarrow{\$} \mathcal{K}_H$
    \item $F_S: \{0,1\}^n \rightarrow \{0,1\}^{l_S}$ is a random function
    \item $\pi: \{0,1\}^n \rightarrow \{0,1\}^n$ is a random permutation
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{\pi, F_S} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1}$
\end{itemize}

By \autoref{collision} the attacker's probability of causing an inner collision is at most
$(\epsilon + 2^{-n})\binom{q}{2}$. If they do not cause a collision,
their queries to $\theta$ meet the constraints set out in \autoref{innerpart}, which
bounds the distinguishing advantage in this case to $2^{-n}\binom{q}{2}$.
The advantage in distinguishing from \xprm{composition}{randinner}
is at most the sum of the collision probability and the no-collision advantage, which is
$(\epsilon + 2(2^{-n}))\binom{q}{2}$.

\xprmtitle{composition}{block}: Choose a random $K_E \xleftarrow{\$} \mathcal{K}_E$ and
substitute a block cipher $E_{K_E}$ for $\pi$.
\begin{itemize}
    \item $K_H \xleftarrow{\$} \mathcal{K}_H$, $K_E \xleftarrow{\$} \mathcal{K}_E$
    \item $F_S: \{0,1\}^n \rightarrow \{0,1\}^{l_S}$ is a random function
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{E_{K_E}, F_S} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1}$
\end{itemize}

By the standard argument
for such a substitution, the advantage for this substitution is at most
$\advantage{\pm \mathrm{prp}}{E_{K_E}}[(q, t')]$ where $t$ is a time bound on the attacker and
$t' = t + \bigO{\sum_i |P^i| + |T^i|}$.

\xprmtitle{composition}{xrf}: Use the random function $F_S$ to derive the keys
$K_E$, $K_H$:

\begin{itemize}
    \item $F_S: (\lambda \cup \{0,1\}^n) \rightarrow \{0,1\}^{l_S}$ is a random function
    \item $K_E || K_H || \ldots = F_S(\lambda)$
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{E_{K_E}, F_S} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1}$
\end{itemize}

This is indistinguishable from \xprm{composition}{block}.

\xprmtitle{composition}{xchacha}: Choose a random $K_S \xleftarrow{\$} \mathcal{K}_S$ and
substitute a stream cipher $S_{K_S}$ for the random function $F_S$

\begin{itemize}
    \item $K_S \xleftarrow{\$} \mathcal{K}_S$
    \item $K_E || K_H || \ldots = S_{K_S}(\lambda)$
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{E_{K_E}, S_{K_S}} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1}$
\end{itemize}

This is HBSH. Taking into account the $|K_E| + |K_H|$-bit
query to $S_{K_S}$ to derive $K_E$, $K_H$,
by the standard argument the advantage for this substitution is at most
$\advantage{\mathrm{prf}}{S_{K_S}}[(|K_E| + |K_H| + \sum_i |P^i|-n, t')]$ (where
the first argument measures not queries but bits of output).

Summing these,
the advantage in distinguishing HBSH from a family of random permutations is at most
$\epsilon\binom{q}{2} + 3(2^{-n})\binom{q}{2}
+ \advantage{\pm \mathrm{prp}}{E_{K_E}}[(q, t')]
+ \advantage{\mathrm{prf}}{S_{K_S}}[(|K_E| + |K_H| + \sum_i |P^i|-n, t')]$.

\printbibliography

\appendix
\section{NHPoly1305}\label{NHPoly1305}

Since the $\epsilon$A$\Delta$U is run twice over the bulk of the block, its speed is especially
crucial. One of the fastest hash functions in software is NH; however, NH has various properties
(issues handling variable length messages, double-sized output) which mean it is generally used
with a second stage of hashing.
In addition, we need a hash function which takes two variable-length inputs.
For HPolyNHC we define a hash function NHPoly1305 which uses NH followed by Poly1305.

\subsection{NH}

We use a
32-bit, unsigned, little-endian, 2-strided variant of NH which is efficient on our target platform.

\begin{align*}
    \NH&: \{0,1\}^{2432} \times \bigcup_{l = 1}^{16} \{0,1\}^{128l}
    \rightarrow \{0,1\}^{256}
\\
    \NH(K, m) &= \eta(K[0;2048], m) | \eta(K[128;2048], m)
    | \eta(K[256;2048], m) | \eta(K[384;2048], m)
\\
    \eta&: \{0,1\}^{2048} \times \bigcup_{l = 1}^{16} \{0,1\}^{128l}
    \rightarrow \{0,1\}^{64}
\\
    \eta(K, m) &= \fromint_{64}\left[
    \sum_{i = 0}^{|m|/128 -1}
    \kappa(K[128i;128], m[128i;128])
    \right]
\\
    \kappa&: \{0,1\}^{128} \times \{0,1\}^{128} \rightarrow \mathbb{Z}
\\
    \kappa(K, m) &= \sum_{i \in {0,32}} \xi(K[i;32], m[i;32]) * \xi(K[i + 64;32], m[i + 64;32])
\\
    \xi&: \{0,1\}^{32} \times \{0,1\}^{32} \rightarrow \mathbb{Z}
\\
    \xi(K, m) &= (\intify(K) + \intify(m)) \mod 2^{32}
\end{align*}
Here $m[a;l]$ refers to the subsequence of $m$ of length $l$ starting at $a$, $\intify$ maps a
sequence of bits to an integer in little-endian fashion, and $y = \fromint_l(x)$ is the unique
$l$-bit sequence such that $\intify(y) \equiv x \;(\textrm{mod}\;2^l)$.
\cite{nh} shows that for equal-length
messages this function is $\epsilon$-almost-$\Delta$-universal on $(\mathbb{Z}/2^{64}\mathbb{Z})^4$
with $\epsilon = 2^{-128}$.

\subsection{Poly1305}

Where we refer to Poly1305 here, we mean specifically the $\epsilon$A$\Delta$U polynomial function
$\Polydjb: \{0,1\}^{128} \times \{0,1\}^* \rightarrow \{0,1\}^n$
based on the finite field $\mathbb{Z}/(2^{130}-5)\mathbb{Z}$, which is defined in \cite{poly1305}
and used to build a MAC which combines this function with the use of AES.
RFC 7539~\cite{RFC7539} takes this
$\epsilon$A$\Delta$U polynomial function and
uses it without AES to build an AEAD mode based on ChaCha20.
Note that 22 bits of the 128-bit key are zeroed before use, so every key is equivalent to
$2^{22}$ keys and the effective keyspace is $2^{106}$.
The output group for which the $\epsilon$A$\Delta$U property applies is
$\mathbb{Z}/2^{128}\mathbb{Z}$, so we define

\begin{align*}
    x \boxplus y &= \fromint_{128}(\intify(x) + \intify(y)) \\
    x \boxminus y &= \fromint_{128}(\intify(x) - \intify(y)) \\
\end{align*}

Many Poly1305 libraries
take parameters $K || g, m$ and return $g \boxplus \Polydjb_K(m)$; where subtraction
is needed we use bitwise inversion and the identity
$g \boxminus g' = \neg ((\neg g) \boxplus g')$.

\subsection{NHPoly1305}
Putting these together, we define a hash function NHPoly1305 with a $128 + 2432 = 2560$-bit key
which takes two variable-length parameters as required by the HBSH construction.
We break the message into 256-byte chunks, padding the last chunk with zeroes to the
nearest 16-byte boundary, and compress each chunk down to 32 bytes with NH.
We then hash with Poly1305 first the lengths of the tweak and the message, followed by the tweak,
followed by padding to a Poly1305 boundary, followed by the NH-compressed chunks of the message
itself.

\begin{algorithmic}[0]
    \Procedure{NHPoly1305}{$(K_H,T,M)$}
    \State $K_0 \gets K_H[0;128]$
    \State $K_1 \gets K_H[128;2432]$
    \State $B \gets \fromint_{64}(|T|) || \fromint_{64}(|M|) || T$
    \If {$|B| \mod 128 \neq 0$}
        \State $B \gets B || 0^{128 - (|B| \mod 128)}$
    \EndIf
    \If {$M \neq \lambda$}
        \State $M_0 || M_1 || \ldots || M_l \gets M$ ($|M_i|=2048$ for $i=0\ldots l-1$, $0 < |M_l| \leq 2048$)
        \If {$|M_l| \mod 128 \neq 0$}
            \State $M_l \gets M_l || 0^{128 - (|M_l| \mod 128)}$
        \EndIf
        \ForAll {$i \in 0\ldots l$}
            \State $B_i \gets \NH_{K_1}(M_i)$
        \EndFor
        \State $B \gets B || B_0 || B_1 || \ldots || B_l$
    \EndIf
    \State \textbf{return} $\Polydjb_{K_0}(B)$
    \EndProcedure
\end{algorithmic}

For distinct pairs $(T,M) \neq (T', M')$, we have that if $|T| \neq |T'|$, $|M| \neq |M'|$, or
$T \neq T'$, then the inputs to Poly1305 will differ. If none of these hold then we have that
$M \neq M'$, and they must differ in some chunk input to NH.
Per \cite{nh} we have that the probability NH will compress these to the same value is at most
$2^{-128}$. The input to Poly1305 is $l_P = 1 + \ceil{|T|/128} + 2\ceil{|M|/2048}$ 16-byte chunks
long, and per \cite{poly1305} Poly1305 is $\epsilon$-almost-$\Delta$-universal with
$\epsilon = l_P2^{-103}$. Our composition is therefore $\epsilon$-almost-$\Delta$-universal
with $\epsilon = 2^{-128} + 2^{-103}l_P$.

If we limit our HPolyNHC attacker to at most $q$ queries each of which uses a tweak of length at
at most $l_T$ and a message of length at most $l_M$, their distinguishing advantage
is therefore at most
$( 2^{-128} + 2^{-103}(1 + \ceil{l_T/128} + 2\ceil{(l_M - 128)/2048}))\binom{q}{2}
 + 3(2^{-n})\binom{q}{2}
+ \advantage{\pm \mathrm{prp}}{E_{K_E}}[(q, t')]
+ \advantage{\mathrm{prf}}{S_{K_S}}[(2816 + q(l_M - 128), t')]$.

Version: \texttt{\input{work/git.tex}}
\end{document}
