% Copyright 2018 Google Inc.
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
%      http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.

%%% script AUTHOR: Paul Crowley, Eric Biggers%%%
%%% script TITLE: {Adiantum}: length-preserving encryption for entry-level processors%%%

\RequirePackage{etoolbox}
\newtoggle{iacr}
\input{work/toggle.tex}
\iftoggle{iacr}{
    \documentclass[journal=tosc,preprint,floatrow,submission]{iacrtrans}
}{ % iacr

    \documentclass[letterpaper,luatex,11pt]{article}

    \usepackage{fontspec}
    \setmainfont{TeX Gyre Pagella}
    \setsansfont{TeX Gyre Heros}
    \setmathrm{Latin Modern Roman}
    \defaultfontfeatures{}
    \setmonofont{TeX Gyre Cursor}[Ligatures={NoCommon,NoRequired,NoContextual},Scale=0.9]

    \usepackage[hmargin=4cm,vmargin=3cm,nohead]{geometry}
    \usepackage{parskip}
    \usepackage[style]{abstract}
    \usepackage{titling}
    \usepackage{sectsty}
    \usepackage{authblk}
    \usepackage{floatrow}
    \usepackage[svgnames]{xcolor}
    \usepackage[breaklinks,colorlinks,urlcolor=DarkBlue,linkcolor=DarkRed,citecolor=DarkGreen]{hyperref}

    \pretitle{\begin{center}\LARGE\bfseries\sffamily} % sf title
    \renewcommand{\abstitlestyle}{\sffamily\bfseries\centering} % sf abstract
    \allsectionsfont{\sffamily} % sf sections

    \raggedright
    \raggedbottom

} % non-iacr

\usepackage[style=alphabetic,backend=biber]{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[logic,probability,advantage,adversary,landau,sets,operators]{cryptocode}
\usepackage{algpseudocode}

\usepackage{tikz}
\usepackage{makecell}

\usepackage{longtable}

\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\XChaCha12}{XChaCha12}
\DeclareMathOperator{\HBSH}{HBSH}
\DeclareMathOperator{\Polydjb}{Poly1305}

\DeclareMathOperator{\NH}{NH}
\DeclareMathOperator{\intify}{int}
\DeclareMathOperator{\fromint}{fromint}
\DeclareMathOperator{\pad}{pad}

\addbibresource{bib.bib}

\usetikzlibrary{positioning}
\usetikzlibrary{groupops}

\newcommand*{\arrowoplus}{\leftarrow\mkern-12mu\oplus}
\newcommand*{\xprm}[2]{\textsf{\ref*{#1}-#2}}
\newcommand*{\xprmtitle}[2]{\textbf{\xprm{#1}{#2}}}
\newcommand*{\calE}{\mathcal{E}}
\newcommand*{\calD}{\mathcal{D}}
\newcommand*{\barE}{\overline{\calE}}
\newcommand*{\barD}{\overline{\calD}}

\title{{Adiantum}: length-preserving encryption for entry-level processors}
\iftoggle{iacr}{
    \author{Paul~Crowley \and Eric~Biggers}
    \institute{Google LLC \\ \email[paulcrowley@google.com,ebiggers@google.com]{{paulcrowley,ebiggers}@google.com}}
}{ % iacr
    \author{Paul~Crowley}
    \author{Eric~Biggers}
    \affil{Google LLC}
} % non-iacr

\tikzset{cbox/.style={
        rectangle,
        thick,
        draw,
        minimum height=1cm,
        text centered,
        anchor=center,
        rounded corners=2pt,
    }
}

\begin{document}
\maketitle
\iftoggle{iacr}{
    \keywords{strong pseudorandom permutation \and
        variable input length \and
        tweakable encryption \and
        disk encryption}
}{ % iacr
} % non-iacr

\begin{abstract}
    We present HBSH, a simple construction for tweakable length-preserving encryption which
    directly supports the fastest options for hashing and stream encryption for processors
    without AES or other crypto instructions, with a provable
    quadratic advantage bound. Our composition Adiantum uses NH, Poly1305, XChaCha12,
    and a single AES invocation. On an ARM Cortex-A7 processor, Adiantum decrypts
    4096-byte messages at 11 cycles per byte, five times faster than
    AES-256-XTS, with a constant-time implementation. We also define HPolyC which is
    simpler and has excellent key agility at 14 cycles per byte.
\iftoggle{iacr}{
}{

    This paper: \url{https://ia.cr/2018/720} \\
    Source: \url{https://github.com/google/hpolyc} \\
    Email: \href{mailto:paulcrowley@google.com,ebiggers@google.com}{\{paulcrowley,ebiggers\}@google.com}
}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
Two aspects of disk encryption make it a challenge for cryptography.  First,
performance is critical; every extra cycle is a worse user experience, and on a mobile device
a reduced battery life.  Second, the ciphertext can be no larger than the plaintext: a sector-sized
read or write to the filesystem must mean a sector-sized read or write to the underlying device,
or performance will again suffer greatly
(as well as, in the case of writes to flash memory, the life of the device).
Nonce reuse is inevitable as there is nowhere to store a varying nonce, and there is no space
for a MAC; thus standard constructions like AES-GCM are not an option and standard notions
of semantic security are unachievable.  The best that can be done under the circumstances is
a ``tweakable super-pseudorandom permutation'': an attacker with access to both encryption
and decryption functions who can choose tweak and plaintext/ciphertext freely is unable to
distinguish it from a family of independent random permutations.

\subsection{History}

Hasty Pudding Cipher~\cite{hpc} was a variable-input-length primitive presented to the AES contest.
A key innovation
was the idea of a ``spice'', which was later formalized as a ``tweak'' in~\cite{tweakable}.
Another tweakable large-block primitive was Mercy~\cite{mercy},
cryptanalyzed in~\cite{mercycryptanalysis}.

\cite{luby-rackoff} (see also~\cite{maurer-luby-rackoff,ppdes})
shows how to construct a pseudorandom permutation using a three-round Feistel
network of pseudorandom functions;
proves that this is not a secure super-pseudorandom permutation (where the adversary
has access to decryption as well as encryption) and that four rounds suffice for this aim.
BEAR and LION~\cite{bearlion} apply this result to an unbalanced Feistel network to build a
large-block cipher from a hash function and a stream cipher (see also BEAST~\cite{beast}).

\cite{fasterlr} shows that a universal function (here called a ``difference concentrator'')
suffices for the first round, which~\cite{NaorReingold} extends to four-round function
to build a super-pseudorandom permutation.

More recently, proposals in this space have focused on the use of
block ciphers. VIL mode~\cite{brvil} is a CBC-MAC based two-pass variable-input-length construction which
is a PRP but not an SPRP. CMC mode~\cite{cmc} is a true SPRP using two passes of the block cipher;
EME mode~\cite{eme} is similar but parallelizable, while
EME* mode~\cite{emestar} extends EME mode to handle blocks that are not a multiple of the block
cipher size. PEP~\cite{pep}, TET~\cite{tet}, and HEH~\cite{heh} have a mixing layer either side of
an ECB layer.

XCB~\cite{xcb} is a block-cipher based unbalanced three-round Feistel network with an
$\epsilon$-almost-XOR-universal hash function for the first and third rounds
(``hash-XOR-hash''),
which uses block
cipher invocations on the narrow side of the network to ensure that the network is an SPRP, rather
than just a PRP; it also introduces a tweak.
HCTR~\cite{hctr,hctr2}, HCH~\cite{hch}, and HMC~\cite{hmc} reduce this to a single
block cipher invocation within the Feistel network.
These proposals require
either two AES invocations, or an AES invocation and two $\GF(2^{128})$ multiplications,
per 128 bits of input.

\subsection{Our contribution}
On the ARM architecture, the ARMv8 Cryptography Extensions include instructions that make
AES and $\GF(2^{128})$ multiplications much more efficient. However,
smartphones designed for developing markets
often use lower-end processors which
don't support these extensions, and as a result there is no existing SPRP construction which performs
acceptably on them.

On such platforms stream ciphers such as ChaCha12~\cite{chacha} significantly
outperform block ciphers in cycles per byte, especially with constant-time implementations.
Similarly, absent specific processor support, hash functions such as NH~\cite{nh} and
Poly1305 hash~\cite{poly1305} will be much faster
than a $\GF(2^{128})$ polynomial hash. Since these are the operations that act on the bulk of
the data in a disk-sector-sized block, a hash-XOR-hash
mode of operation relying on them should achieve
much improved performance on such platforms.

To this end, we present the HBSH (hash, block cipher, stream cipher, hash)
construction, which generalizes over constructions such as
HCTR and HCH by taking an $\epsilon$-almost-$\Delta$-universal hash function and a
nonce-accepting stream cipher
as components. Based on this construction, our main proposal is Adiantum,
which uses a combination of NH and Poly1305 for the hashing, XChaCha12 for the stream cipher, and
AES for the single blockcipher application. Adiantum:
\begin{itemize}
    \item is a tweakable, variable-input-length, super-pseudorandom permutation
    \item has a security bound quadratic in the number of queries and linear in message length
    \item is highly parallelizable
    \item needs only three passes over the bulk of the data, or
        two if the XOR is combined with the second hash.
\end{itemize}

Without special cases or extra setup, Adiantum handles:
\begin{itemize}
    \item any message and tweak lengths within the allowed range,
    \item varying message and tweak lengths for the same keys.
\end{itemize}

We also describe a simpler proposal, HPolyC, which sacrifices a little speed on large blocks
for simplicity and greater key agility, leaving out the NH hash layer.

The proof of security differs from other hash-XOR-hash modes in three ways. First,
Poly1305 hash is not XOR universal, but universal over $\ZZ/2^{128}\ZZ$,
so for XOR of hash values we substitute addition and subtraction in the appropriate group.
Second, using the XSalsa20 construction~\cite{xsalsa}, we can directly
build a stream cipher which takes a 192-bit nonce to generate a stream, simplifying
the second Feistel operation and associated proof, as well as subkey generation.
Finally, Poly1305 hash has a much weaker security bound than the $\GF(2^{128})$ polynomial hash;
the proof is shaped around ensuring we pay the smallest multiple of this cost we can.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Specification}
The HBSH construction is shown in \autoref{pseudocode}. It uses a stream cipher $S$, an
$\epsilon$-almost-$\Delta$-universal function $H$, and an $n$-bit block cipher $E$.
From plaintext $P$ of at least $n$ bits and a tweak $T$,
it generates a ciphertext $C$ of the same length as $P$.
HBSH divides the plaintext into a right-hand block of $n$ bits and a left-hand block with
the remainder of the input, and applies an unbalanced Feistel network.
$P_R$, $P_M$, $C_M$, $C_R$ are $n$ bits long.

\begin{figure}
    \begin{floatrow}
        \ffigbox{
            \input{finalfig.tex}
        }{
            \caption{HBSH}\label{finalfig}
        }
        \ffigbox{
            \begin{algorithmic}[0]
                \Procedure{HBSHEncrypt}{$T,P$}
                \State $P_L || P_R \gets P$
                \State $P_M \gets P_R \boxplus H_{K_H}(T, P_L)$
                \State $C_M \gets E_{K_E}(P_M)$
                \State $C_L \gets P_L \arrowoplus S_{K_S}(C_M)$
                \State $C_R \gets C_M \boxminus H_{K_H}(T, C_L)$
                \State $C \gets C_L || C_R$
                \State \textbf{return} $C$
                \EndProcedure
            \end{algorithmic}
            \begin{algorithmic}[0]
                \Procedure{HBSHDecrypt}{$T,C$}
                \State $C_L || C_R \gets C$
                \State $C_M \gets C_R \boxplus H_{K_H}(T, C_L)$
                \State $P_L \gets C_L \arrowoplus S_{K_S}(C_M)$
                \State $P_M \gets E_{K_E}^{-1}(C_M)$
                \State $P_R \gets P_M \boxminus H_{K_H}(T, P_L)$
                \State $P \gets P_L || P_R$
                \State \textbf{return} $P$
                \EndProcedure
            \end{algorithmic}
        }{\caption{Pseudocode for HBSH}\label{pseudocode}}
    \end{floatrow}
\end{figure}

\subsection{Notation}
Partial application is implicit; if we define $f: A \times B \rightarrow C$ and
$a \in A$ then $f_a: B \rightarrow C$, and if $f_a^{-1}$ exists then $f_a^{-1}(f_a(b)) = b$.
$||$ represents concatenation, and $\lambda$ the empty string.
$|X|$ represents the length of $X \in \bin^{*}$ in bits.
$Y[a;l]$ refers to the subsequence of $Y$ of length $l$ starting at $a$.
$X \arrowoplus Y$ is $X \oplus Y[0;|X|]$.
$\pad_l(X) = X||0^v$ where $v$ is the least integer $\geq 0$ such that $l$ divides $|X| + v$.
$\boxplus$ represents addition in a group which depends
on the hash function, and $\boxminus$ subtraction.

\subsection{Block cipher}
The $n$-bit block cipher $E: \mathcal{K}_E \times \bin^n \rightarrow \bin^n$
is only invoked once no matter the size of the input, so for disk sector-sized inputs
its performance isn't critical. Adiantum and HPolyC use AES-256~\cite{AES}, so $n = 128$.

\subsection{Stream cipher}
$S: \mathcal{K}_S \times (\lambda \cup \bin^n) \rightarrow \bin^{l_S}$
is a stream cipher which takes a key and a nonce and produces a long random stream. In normal use
the nonce is an $n$-bit string, but for key derivation we use the empty string $\lambda$, which
is distinct from all $n$-bit strings.

Adiantum and HPolyC use the XChaCha12 stream cipher. This is based on ChaCha12~\cite{chacha}, but
ChaCha12 only takes a 64-bit (or 96-bit~\cite{RFC7539}) nonce, which is too small for our purposes,
so we use the
XSalsa20 construction~\cite{xsalsa} initially proposed for Salsa20~\cite{salsa20,salsa812}
to construct XChaCha12 which extends the nonce to 192 bits
(as libsodium~\cite{xchacha20}
and Monocypher~\cite{monocypher} do
with ChaCha20). From here we construct a function that takes a variable-length nonce of up to
191 bits by padding with a 1 followed by zeroes:
$S_{K_S}(C_M) = \XChaCha12_{K_S}(\pad_{192}(C_M || 1))$. For a
given key and nonce, XChaCha12 produces $l_S = 2^{73}$ bits of output; we
therefore require that the plaintext length be within the bounds
$n \leq |P| \leq l_S + n$.

\subsection{Hash}
$H: \mathcal{K}_H \times \bin^{*} \times \bin^{*} \rightarrow \bin^n$
is an $\epsilon$-almost-$\Delta$-universal ($\epsilon$A$\Delta$U) function on pairs
of bitstrings, yielding a group element represented as an $n$-bit string.

HPolyC and Adiantum differ only in their choice of hash function, as described in \autoref{hashing}.
In both cases, the group used for $\boxplus$ and $\boxminus$ is $\ZZ/2^{128}\ZZ$.
The value of $\epsilon$ depends on bounds on the input lengths, as set out in that appendix.

\subsection{Key derivation}\label{keyderivation}
HBSH derives $K_H$ and $K_E$ from $K_S$ using a zero-length nonce:
$K_E || K_H || \ldots = S_{K_S}(\lambda)$.\footnote{In the original
version of this paper, HPolyC used $K_H || K_E || \ldots = S_{K_S}(\lambda)$.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design}
Any secure PRP must have a pass that reads all of the plaintext, followed by a pass that modifies
it all. A secure SPRP must have the same property in the reverse direction;
a three-pass structure therefore seems natural.
$\epsilon$A$\Delta$U functions are the fastest options for reading the plaintext in a
cryptographically useful way, and stream ciphers are the fastest options for modifying it.
$\epsilon$A$\Delta$Us
are typically much faster than stream ciphers, and so the hash-XOR-hash structure emerges as
the best option for performance. This structure also has the advantage that it naturally handles
blocks in non-round sizes; many large-block modes need extra wrinkles akin to ciphertext stealing
to handle the case where the large-block size is not
a multiple of the block size of the underlying primitive.

\cite{luby-rackoff} observes that a three-round Feistel network cannot by itself be a secure SPRP;
a simple attack with two plaintexts and one ciphertext distinguishes it. A single block cipher call
in the narrow part of the unbalanced network suffices to frustrate this attack; the
larger the block, the smaller the relative cost of this call.
Compared to HCTR~\cite{hctr} or HCH~\cite{hch}, we sacrifice
symmetry of encryption with decryption in return for
the ability to run the block cipher and stream cipher in parallel when decrypting.
For disk encryption, decryption performance matters most:
reads are more frequent than writes, and reads generally affect user-perceived latency, while
operating systems can usually perform writes asynchronously in the background.

It's unusual for a construction to require more than two distinct building blocks.
More commonly, a hash-XOR-hash mode uses the block cipher to build a stream cipher
(eg using CTR mode~\cite{ctr})
as well as using it directly on the narrow side of the block.
Using XChaCha12 in place of a block cipher affords a significant increase in performance;
however it cannot easily be substituted in the narrow side of the cipher.
\cite{sarkar1,sarkar2,sarkar3,sarkar4} use only an $\epsilon$AXU function
and a stream cipher, and build a hash-XOR-hash SPRP
with a construction that uses a four-round Feistel network over the non-bulk side of the data
broken into two halves. However if we were to build this using XChaCha12,
such a construction would require four extra invocations of ChaCha per block, which would be
a much greater cost than one block cipher invocation.

We do not consider an attack model in which derived keys are presented as input.
Length-preserving encryption
which is KDM-secure in the sense of~\cite{kdm} is impossible, since it is trivial for the
attacker to submit a query with a $g$-function
that constructs a plaintext whose ciphertext is all zeroes.
Whether there is a notion of KDM-security that can be
applied in this domain is an open problem. Users must take care to protect the keys from being
included in the input.

Since the $\epsilon$A$\Delta$U is run twice over the bulk of the block, its speed is especially
crucial for large blocks. One of the fastest such functions in software is NH~\cite{nh}, and
it's also appealingly simple; however as discussed in~\autoref{nh} it generally has to be
combined with a second hashing stage, and for this purpose we use Poly1305. The 1k block size
used for NH means that we can use a simple, portable implementation of Poly1305 without a great
cost in speed.  We considered using UHASH (as defined for UMAC~\cite{rfc4418}) rather than our
custom combination of NH and Poly1305; however, available UHASH implementations
are not constant-time, and a constant-time implementation would be significantly
slower.

For the 4k blocks of disk encryption,
the 1k NH key size has only a small impact on key agility. Applications
that need high key agility even on small blocks may instead use HPolyC, which
uses Poly1305 directly. For this a vectorized Poly1305 implementation is important.  The main
cost of a new HPolyC key is a single XChaCha12 invocation to generate subkeys.
ChaCha12 has no key schedule
and makes no use of precomputation; XChaCha12 has a ``nonce scheduling'' step
that must be called once to compute subkeys and once for each encryption or
decryption.  No extra work is required for differing message or tweak lengths for either Adiantum
or HPolyC.

NH, Poly1305 and ChaCha12 are designed such that the most natural fast implementations are
constant-time and free from data-dependent lookups. So long as the block cipher implementation
also has these properties, Adiantum and HPolyC will inherit security against
this class of side-channel attacks.

NH, Poly1305 and ChaCha12 are highly parallelizable.
The stream cipher and second hash stages can also be run in combination for a total
of two passes over the bulk of the data, unlike a mode such as HEH~\cite{heh}
which requires at least three.
We put the ``special'' block on the right so that in typical uses the bulk encryption has
the best alignment for fast operations.

``Adiantum'' is the genus of the maidenhair fern, which in the language of
flowers (floriography) signifies sincerity and discretion.~\cite{fleurs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Performance}

In \autoref{performance} we
show performance on an ARM \mbox{Cortex-A7}
processor in the Snapdragon 400 chipset running at \mbox{1.19 GHz}.  This
processor supports the NEON vector instruction set, but not the ARM cryptographic
extensions; it is used in many smartphones and smartwatches, especially low-end
devices, and is representative of the kind of platform we mean to target.
Where the figures are within 2\%, a single row is shown for both encryption and
decryption.

\begin{table}
    \caption{Performance on ARM Cortex-A7}
    \label{performance}
    \centering
    \begin{tabular}{lrr}
        Algorithm &
            \makecell{Cycles per byte \\ (4096-byte sectors)} &
            \makecell{Cycles per byte \\ (512-byte sectors)} \\
    \hline
    \input{work/performance.tex}
    \end{tabular}
\end{table}

We have prioritized performance on 4096-byte messages, but we also tested 512-byte messages.
512-byte disk sectors were the standard until the introduction of Advanced Format in 2010;
modern large hard drives and flash drives now use 4096-byte sectors.
On Linux, 4096 bytes is the standard page size, the standard allocation unit size for filesystems,
and the granularity of \textit{fscrypt} file-based encryption, while
\mbox{\textit{dm-crypt}} full-disk encryption has recently been updated
to support this size.

For comparison we evaluate against various block ciphers in XTS mode~\cite{xts}:
AES\mbox~\cite{AES}, Speck~\cite{speck1,speck2,speck3}, NOEKEON~\cite{noekeon},
and XTEA~\cite{xtea}. We also include the performance of ChaCha, NH,
and Poly1305 by themselves for reference.
We used the fastest constant-time implementation of each algorithm we were able
to find or write for the platform; see \autoref{implementation}.  In every case
except \texttt{aes\_ti.c},
the performance-critical parts were written in assembly language using NEON
instructions.

\begin{table}
    \caption{Implementations}
    \label{implementation}
    \centering
    \begin{tabular}{llp{7cm}}
        Algorithm & Source & Notes \\
    \hline
    ChaCha & Linux v4.17 & \texttt{chacha20-neon-core.S}, modified to support
        ChaCha8 and ChaCha12; also applied optimizations from \texttt{cryptodev}
        commit a1b22a5f45fe8841 \\
    Poly1305 & OpenSSL 1.1.0h & \texttt{poly1305-armv4.S}, modified to allow key
    powers to be computed just once per key \\
    \mbox{AES} & Linux v4.17 & \texttt{aes\_ti.c}, used once per message in HBSH \\
    \mbox{AES-XTS} & Linux v4.17 & \texttt{aes-neonbs-core.S} (bit-sliced) \\
    \mbox{Speck128/256-XTS} & Linux v4.17 & \texttt{speck-neon-core.S} \\
    \mbox{NOEKEON-XTS} & ours & \\
    \mbox{XTEA-XTS} & ours & \\
    \end{tabular}
\end{table}

Adiantum and HPolyC are the only algorithms in \autoref{performance} that are tweakable
super-pseudorandom permutations over the entire sector.  We expect any AES-based
construction to that end to be significantly slower than \mbox{AES-XTS}.

We conclude that for 4096-byte sectors, \mbox{Adiantum-XChaCha12-AES} can perform
significantly better than an aggressively designed block cipher (\mbox{Speck128/256}) in XTS mode.
Efficient implementations of NH, Poly1305 and ChaCha are available for many
platforms, as these algorithms are well-suited for implementation with either
general-purpose scalar instructions or with general-purpose vector instructions
such as NEON or AVX2.
For a greater margin of security at a slower speed, ChaCha20 can
be used instead of ChaCha12; the same stream cipher
must be used for key derivation as for the Feistel function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Security reduction}
HBSH is a tweakable, variable-input-length, secure pseudorandom permutation: an attacker
succeeds if they distinguish it from a family of independent random permutations indexed by
input length and tweak, given access to both encryption and decryption oracles.

Given keys $K_S$, $K_H$, $K_E$, HBSH is the conjugation of an inner transform by an outer:
\begin{align*}
    \HBSH:
    \bin^* &\times \bin^l \times \bin^n \rightarrow \bin^l \times \bin^n \\
    \HBSH_{T} &= \phi^{-1}_{K_H, T}
    \circ \theta_{E_{K_E}, S_{K_S}} \circ \phi_{K_H, T} \\
    \theta_{e, s}(P_L, P_M) &= (P_L \arrowoplus s(e(P_M)), e(P_M)) \\
    \phi_{K_H, T}(L, R) &= (L, R \boxplus H_{K_H}(T, L)) \\
    \phi^{-1}_{K_H, T}(L, R) &= (L, R \boxminus H_{K_H}(T, L))
\end{align*}

These are families of length-preserving functions parameterized by the length
$|P_L| = |L| = |C_L| = l \in \mathbb{N}$;
for notational convenience we leave this parameter implicit.

We prove a security bound for HBSH in three stages:
\begin{itemize}
    \item we consider distinguishers for the inner construction $\theta$ in an
    attack model which forbids ``inner collisions'' in queries
    \item we prove a bound on the probability of an attacker causing an inner collision
    \item we put this together to bound the success probability of a distinguisher against
    HBSH.
\end{itemize}

At each stage, we consider an attacker \(\adv^{\calE, \calD}\) who makes $q$ queries
to oracles for
two length-preserving function families which take a tweak; the attacker is always free to vary
the length of input and tweak.

\begin{align*}
\calE, \calD:
\bin^* &\times \bin^l \times \bin^n \rightarrow \bin^l \times \bin^n \\
(C_L, C_R) &\leftarrow \calE_T(P_L, P_R) \\
(P_L, P_R) &\leftarrow \calD_T(C_L, C_R) \\
\end{align*}

\subsection{Inner part}\label{innerpart}

We consider an attacker trying to distinguish an idealized $\theta$ from a
pair of families of random length-preserving functions,
but we forbid the attacker from causing ``inner collisions'':
having made either of the queries: \label{constraints}
\begin{itemize}
    \item $(C_L, C_M) \leftarrow \calE_T(P_L, P_M)$
    \item $(P_L, P_M) \leftarrow \calD_T(C_L, C_M)$
\end{itemize}
both of the queries below are subsequently disallowed:
\begin{itemize}
    \item $\calE_\cdotp(\cdotp, P_M)$
    \item $\calD_\cdotp(\cdotp, C_M)$
\end{itemize}
where $\cdotp$ represents any value. However assuming $C_M \neq P_M$, this does not disallow
subsequent queries of the form $\calD_\cdotp(\cdotp, P_M)$ or $\calE_\cdotp(\cdotp, C_M)$
and it's important to consider such queries at each step below. We write
$P_M$/$C_M$ for the second argument and result to match notation used for $\theta$ elsewhere.
At this stage, we consider computationally unbounded attackers; we'll consider resource-bounded
attackers in~\autoref{composition}.

In what follows we use a standard concrete security hybrid argument per~\cite{concrete,games}:
for a fixed class of attacker, distinguishing advantage obeys the triangle inequality and
forms a pseudometric space. We consider a
sequence of experiments, bound the distinguishing advantage between successive
experiments, and thereby
prove an advantage bound for a distinguisher between the first and the last experiment
which is the sum of the advantage bound between each successive experiment.

\xprmtitle{innerpart}{randinner}: $\calE$ and $\calD$ are families of
random functions. Since by our constraints above every query to each
is distinct, every output of the
appropriate length is equally likely. Wherever we specify that an experiment uses multiple random
functions, those functions are independent unless stated otherwise.

\xprmtitle{innerpart}{notweak}: Ignore the tweak: let
$\barE, \barD$ be random length-preserving function families from
$\bin^l \times \bin^n \rightarrow \bin^l \times \bin^n$
and let $\calE_T = \barE$ and $\calD_T = \barD$ for all $T$.
Since by the above constraints, for each random function the second argument in every query
is still always distinct, every output of the appropriate length is equally
likely as before, and this is indistinguishable from \xprm{innerpart}{randinner}.

\xprmtitle{innerpart}{doublerf}: Use a Feistel network in which the stream cipher
nonce includes both $P_M$ and $C_M$.
\begin{itemize}
    \item $F_S: \bin^{2n} \rightarrow \bin^{l_S}$ is a random
    function
    \item $F_E, F_D: \bin^n \rightarrow \bin^n$ are random functions
    \item $\calE_T(P_L, P_M) = (P_L \arrowoplus F_S(P_M || F_E(P_M)), F_E(P_M))$
    \item $\calD_T(C_L, C_M) = (C_L \arrowoplus F_S(F_D(C_M) || C_M), F_D(C_M))$
\end{itemize}
Again, the constraints above ensure that for each random function,
every query is distinct,
every output of the appropriate length is equally
likely as before, and this is indistinguishable from
\xprm{innerpart}{notweak} and \xprm{innerpart}{randinner}.

\xprmtitle{innerpart}{rpswitch}: Substitute a random permutation for the pair of random functions.
\begin{itemize}
    \item $F_S: \bin^{2n} \rightarrow \bin^{l_S}$ is a random function as before
    \item $\pi: \bin^n \rightarrow \bin^n$ is a random permutation
    \item $\calE_T(P_L, P_M) = (P_L \arrowoplus F_S(P_M || \pi(P_M)), \pi(P_M))$
    \item $\calD_T(C_L, C_M) = (C_L \arrowoplus F_S(\pi^{-1}(C_M) || C_M), \pi^{-1}(C_M))$
    ie $\calD_T = \calE_T^{-1}$
\end{itemize}
The constraints above rule out ``pointless'' queries on $\pi$, so per section C of~\cite{cmc}
the advantage in distinguishing this from \xprm{innerpart}{doublerf} is at most
$2^{-n}\binom{q}{2}$.

\xprmtitle{innerpart}{halfrf}: Replace the two-argument $F_S$ with
a single-argument version which uses only $C_M$.
\begin{itemize}
    \item $F_S: \bin^n \rightarrow \bin^{l_S}$ is a random function
    \item $\pi: \bin^n \rightarrow \bin^n$ is a random permutation as before
    \item $\calE_T(P_L, P_M) = (P_L \arrowoplus F_S(\pi(P_M)), \pi(P_M))$
    ie $\calE_T = \theta_{\pi, F_S}$
    \item $\calD_T(C_L, C_M) = (C_L \arrowoplus F_S(C_M), \pi^{-1}(C_M))$
    ie $\calD_T = \theta_{\pi, F_S}^{-1}$
\end{itemize}
Since $\pi$ is a permutation,
for any pair of queries $C_M = C_M'$ if and only if $P_M = P_M'$.
This is therefore indistinguishable from \xprm{innerpart}{rpswitch}.
This is a small upside to HBSH's asymmetry: if a symmetrical
construction such as $F_S(P_M \oplus \pi(P_M))$ were used here instead, it would be
distinguishable with advantage $2^{-n}\binom{q}{2}$.

Summing these distances, with these constraints the advantage distinguishing between
\xprm{innerpart}{randinner} and \xprm{innerpart}{halfrf} is at most
$2^{-n}\binom{q}{2}$.

\subsection{Collision finding}\label{collision}
We now bound the probability that the attacker will cause an
``inner collision''---a query to the inner part which doesn't meet the constraints described
in \autoref{constraints}.

We assume $H$ is $\epsilon$-almost-$\Delta$-universal:
for any $g \in \bin^n$ and
any two distinct messages $(T, M) \neq (T', M')$,
$\probsub{K_H \sample \mathcal{K}_H}{H_{K_H}(T, M) \boxminus H_{K_H}(T', M') = g} \leq \epsilon$.
Adiantum and HPolyC differ only in the choice of $H$ function, and we defer the
description of these functions and their $\epsilon$A$\Delta$U property to \autoref{hashing},
noting here that for both, the value of $\epsilon$ will depend
on the maximum length of the message and tweak we allow the attacker to query for.

From here on, we forbid only ``pointless queries'': after either of the queries
$(C_L, C_R) \leftarrow \calE_T(P_L, P_R)$ or $(P_L, P_R) \leftarrow \calD_T(C_L, C_R)$,
both the subsequent queries
$\calE_T(P_L, P_R)$ and $\calD_T(C_L, C_R)$ would be forbidden. Again, we consider a
computationally unbounded attacker.

A hash key $K_H \sample \mathcal{K}_H$ is chosen at random, and for each query we define
\begin{itemize}
    \item $P_M = P_R \boxplus H_{K_H}(T, P_L)$
    \item $C_M = C_R \boxplus H_{K_H}(T, C_L)$
\end{itemize}

For query $1 \leq i \leq q$, we'll use superscripts to refer to the variables for that query, eg
$P_M^i$, $C_M^i$. The attacker wins if there exists $i < j \leq q$ such that
either
\begin{itemize}
    \item $j$ is a plaintext query (a query to $\calE$) and $P_M^i = P_M^j$ or
    \item $j$ is a ciphertext query (a query to $\calD$) and $C_M^i = C_M^j$.
\end{itemize}
We do not consider a query such that $C_M^i = P_M^j$ (or vice versa) a win.

Here we are considering not distinguishing probability but success probability; we
show a bound on success probability for the first experiment, and for each subsequent experiment
we bound the increase in success probability over the previous experiment.

\xprmtitle{collision}{keyend}: Choose responses fairly at random of the appropriate length;
once all $q$ queries are complete, choose the hash key and see if the attacker succeeded.

If query $j$ is a plaintext query, the attacker knows the query and result
for all $i < j$, and can choose plaintext values to maximize the probability of success.
If $T^i, P_L^i = T^j, P_L^j$ then the hashes will be the same, and since pointless
queries are forbidden we have that $P_R^i \neq P_R^j$ and therefore that
$P_M^i \neq P_M^j$. Otherwise by the $\epsilon$A$\Delta$U property,
$\prob{P_M^i = P_M^j} \leq \epsilon$. The same success bound holds for a ciphertext query.
The overall probability of success
is at most the sum of the probability of success for each pair:
$\epsilon\binom{q}{2}$.

Note that we don't assume that probabilities are independent here;
for any events $A$, $B$ we have that $\prob{A \vee B} \leq \prob{A} + \prob{B}$, with
equality if $A$, $B$ are disjoint.

\xprmtitle{collision}{keystart}: As with \xprm{collision}{keyend}, but
choose the hash key at the start of the experiment. This
does not change the probability of success.

\xprmtitle{collision}{earlystop}: As with \xprm{collision}{keystart}, but
end the experiment as soon as the attacker succeeds.
This doesn't change the success probability.

\xprmtitle{collision}{randomfuncs}: Use random function families for $\calE$,
$\calD$. Since we forbid pointless queries,
all responses of the appropriate length are equally likely as before,
and this doesn't change the success probability.

\xprmtitle{collision}{randinner}: Use random function families for $\calE'$, $\calD'$, and define
\begin{itemize}
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \calE_T' \circ \phi_{K_H, T}$
    \item $\calD_T = \phi^{-1}_{K_H, T} \circ \calD_T' \circ \phi_{K_H, T}$
\end{itemize}

Since a random function composed with a bijective function is a random function,
this doesn't change the success probability, which remains at most
$\epsilon\binom{q}{2}$.

\xprmtitle{collision}{halfrf}: The middle part of the sandwich is now a pair of random functions,
as per the first experiment in \autoref{innerpart}, \xprm{innerpart}{randinner}.
Substitute this with the last experiment, \xprm{innerpart}{halfrf}:

\begin{itemize}
    \item $F_S: \bin^n \rightarrow \bin^{l_S}$ is a random function
    \item $\pi: \bin^n \rightarrow \bin^n$ is a random permutation
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{\pi, F_S} \circ \phi_{K_H, T}$
    \item $\calD_T = \phi^{-1}_{K_H, T} \circ \theta_{\pi, F_S}^{-1} \circ \phi_{K_H, T} = \calE_T^{-1}$
\end{itemize}

Given any attacker against \xprm{collision}{halfrf},
we construct a distinguisher between \xprm{innerpart}{randinner} and \xprm{innerpart}{halfrf} as
follows: we choose a random $K_H$, and use our oracle for the inner part as $\theta$.
We report 1 if the attacker succeeds in generating an inner collision.
We stop the experiment early if the attacker succeeds, and any query in which the attacker
does not succeed is one that obeys the query bounds of \autoref{innerpart}.
Therefore, the difference in success probability
between \xprm{collision}{randinner} and \xprm{collision}{halfrf}
for these two outer experiments can be no more than
the advantage bound of $2^{-n}\binom{q}{2}$
established in~\autoref{innerpart} for distinguishing between
\xprm{innerpart}{randinner} and \xprm{innerpart}{halfrf}.
The success
probability for this final experiment is therefore at most
$(\epsilon + 2^{-n})\binom{q}{2}$.

\subsection{Composition}\label{composition}

Finally we put these pieces together to bound the advantage of distinguishing HBSH from
a family of random permutations. As before, the attacker can make encryption and decryption queries
but ``pointless'' queries are forbidden; in addition, the attacker is constrained by a time
bound $t$. We start with this experiment:

\xprmtitle{composition}{permutation}: For all lengths and all $T$, $\calE_T$ is a random permutation,
and $\calD_T = \calE_T^{-1}$. The security of a variable-length tweakable SPRP is defined by
the advantage bound in distinguishing it from this experiment.

\xprmtitle{composition}{randomfuncs}: $\calE$ and $\calD$ are
families of random functions.
Since pointless queries are forbidden, the advantage in distinguishing this from
\xprm{composition}{permutation} is at most $2^{-|P|}\binom{q}{2} \leq 2^{-n}\binom{q}{2}$
per section C of~\cite{cmc}.

\xprmtitle{composition}{randinner}: $\calE'$ and $\calD'$ are families of random functions.
Choose a hash key $K_H \sample \mathcal{K}_H$,
and conjugate the random functions by Feistel calls to the hash function:

\begin{itemize}
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \calE_T' \circ \phi_{K_H, T}$
    \item $\calD_T = \phi^{-1}_{K_H, T} \circ \calD_T' \circ \phi_{K_H, T}$
\end{itemize}

as per the step from \xprm{collision}{randomfuncs}
to \xprm{collision}{randinner}.
Since a random function composed with a bijective function is a random function,
this is indistinguishable from \xprm{composition}{randomfuncs}.

\xprmtitle{composition}{halfrf}: Substitute \xprm{innerpart}{halfrf} for \xprm{innerpart}{randinner}.
\begin{itemize}
    \item $K_H \sample \mathcal{K}_H$
    \item $F_S: \bin^n \rightarrow \bin^{l_S}$ is a random function
    \item $\pi: \bin^n \rightarrow \bin^n$ is a random permutation
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{\pi, F_S} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1}$
\end{itemize}

By \autoref{collision} the attacker's probability of causing an inner collision is at most
$(\epsilon + 2^{-n})\binom{q}{2}$. If they do not cause a collision,
their queries to $\theta$ meet the constraints set out in \autoref{innerpart}, which
bounds the distinguishing advantage in this case to $2^{-n}\binom{q}{2}$.
The advantage in distinguishing from \xprm{composition}{randinner}
is at most the sum of the collision probability and the no-collision advantage, which is
$(\epsilon + 2(2^{-n}))\binom{q}{2}$.

\xprmtitle{composition}{block}: Choose a random $K_E \sample \mathcal{K}_E$ and
substitute a block cipher $E_{K_E}$ for $\pi$.
\begin{itemize}
    \item $K_H \sample \mathcal{K}_H$, $K_E \sample \mathcal{K}_E$
    \item $F_S: \bin^n \rightarrow \bin^{l_S}$ is a random function
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{E_{K_E}, F_S} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1}$
\end{itemize}

By the standard argument
for such a substitution, the advantage for this substitution is at most
$\advantage{\pm \mathrm{prp}}{E_{K_E}}[(q, t')]$ where $t$ is a time bound on the attacker and
$t' = t + \bigO{\sum_i \left( |P^i| + |T^i| \right)}$.

\xprmtitle{composition}{xrf}: Use the random function $F_S$ to derive the keys
$K_E$, $K_H$:

\begin{itemize}
    \item $F_S: (\lambda \cup \bin^n) \rightarrow \bin^{l_S}$ is a random function
    \item $K_E || K_H || \ldots = F_S(\lambda)$
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{E_{K_E}, F_S} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1}$
\end{itemize}

This is indistinguishable from \xprm{composition}{block}.

\xprmtitle{composition}{xchacha}: Choose a random $K_S \sample \mathcal{K}_S$ and
substitute a stream cipher $S_{K_S}$ for the random function $F_S$

\begin{itemize}
    \item $K_S \sample \mathcal{K}_S$
    \item $K_E || K_H || \ldots = S_{K_S}(\lambda)$
    \item $\calE_T = \phi^{-1}_{K_H, T} \circ \theta_{E_{K_E}, S_{K_S}} \circ \phi_{K_H, T}$
    \item $\calD_T = \calE_T^{-1}$
\end{itemize}

This is HBSH. Taking into account the $|K_E| + |K_H|$-bit
query to $S_{K_S}$ to derive $K_E$, $K_H$,
by the standard argument the advantage for this substitution is at most
$\advantage{\mathrm{prf}}{S_{K_S}}[\left(|K_E| + |K_H| + \sum_i \left(|P^i|-n\right), t'\right)]$
where the first argument measures not queries but bits of output.

Summing these,
the advantage in distinguishing HBSH from a family of random permutations is at most

\begin{align*}
& (\epsilon + 3(2^{-n}))\binom{q}{2} \\
+& \advantage{\pm \mathrm{prp}}{E_{K_E}}[(q, t')] \\
+& \advantage{\mathrm{prf}}{S_{K_S}}[\left(|K_E| + |K_H| + \sum_i \left(|P^i|-n\right), t'\right)]
\end{align*}

\printbibliography

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\section{$\epsilon$A$\Delta$U functions for HBSH}\label{hashing}

Adiantum and HPolyC are identical except for the choice of $\epsilon$A$\Delta$U hash function
$H_{K_H}(T, M)$. In each case the value of $\epsilon$ depends on bounds on $|T|$ and $|M|$.
If queries to HBSH are bounded to a maximum tweak and plaintext/ciphertext length of
$|T| \leq l_T$, $|P|, |C| \leq l_P$
then the bounds on queries to $H$ will be $|T| \leq l_T$, $|M| \leq l_M = l_P - n$.

\subsection{Notation}

$\intify: \bin^{*} \rightarrow \ZZ$ is the
standard little-endian map
(ie $\intify(\lambda) = 0$, $\intify(0 || X) = 2\intify(X)$, $\intify(1 || X) = 1 + 2\intify(X)$),
and $X = \fromint_l(y)$ is the unique
$l$-bit sequence such that $\intify(X) \equiv y \pmod{2^l}$.

For both Adiantum and HPolyC,
the output group for which the $\epsilon$A$\Delta$U property applies is
$\ZZ/2^{128}\ZZ$, so we define

\begin{align*}
    x \boxplus y &= \fromint_{128}(\intify(x) + \intify(y)) \\
    x \boxminus y &= \fromint_{128}(\intify(x) - \intify(y)) \\
\end{align*}

\subsection{Poly1305}

\cite{poly1305} uses polynomials over the finite field $\ZZ/(2^{130}-5)\ZZ$
to define a function we call
$\Polydjb: \bin^{128} \times \bin^* \rightarrow \bin^{128}$,
and proves in Theorem 3.3 that it is $\epsilon$A$\Delta$U: for any
$g \in \bin^{128}$ and any distinct messages $M, M'$ where $|M|, |M'| \leq l$,
$\probsub{K_H \sample{\bin^{128}}}{H_{K_H}(M') \boxminus H_{K_H}(M) = g} \leq 2^{-103}\ceil{l/128}$.
In that paper this function is used to build a MAC based on AES, while in
RFC 7539~\cite{RFC7539} it's used to build an AEAD mode based on ChaCha20.
Note that 22 bits of the 128-bit key are zeroed before use, so every key is equivalent to
$2^{22}$ keys and the effective keyspace is $2^{106}$.

Many Poly1305 libraries
take parameters $K_H || g, M$ and return $g \boxplus \Polydjb_{K_H}(M)$; where subtraction
is needed we suggest using bitwise inversion and the identity
$g \boxminus g' = \neg ((\neg g) \boxplus g')$.

\subsection{HPolyC hashing}
HPolyC was the HBSH construction that the first revision of this paper presented, which used
Poly1305 together with an injective encoding function.
It is simple, fast, and key agile. We require that $|T| < 2^{32}$ and define
\begin{align*}
H_{K_H}(T, M) = \Polydjb_{K_H}(\pad_{128}(\intify_{32}(|T|) || T) || M)
\end{align*}

Thus if for all queries $|T| \leq l_T$ and $|M| \leq l_M$ then:

\begin{displaymath}
\epsilon = 2^{-103}(\ceil{(32 + l_T)/128} + \ceil{l_M/128})
\end{displaymath}

\subsection{NH}\label{nh}

We define a word size $w = 32$, a stride $s = 2$,
a number of rounds $r = 4$ and an input size multiplier $u = 64$.

NH is then defined over message
lengths divisible by $2sw = 128$
and takes a key of length $2sw(u + r -1) = 8576$, processing the message
in $2usw = 8192$-bit chunks to produce
an output of size $2rw\ceil{|M|/2usw}$.

\begin{algorithmic}[0]
    \Procedure{NH}{$K, M$}
    \State $h \gets \lambda$
    \While {$M \neq \lambda$}
        \State $l \gets \min{(|M|, 2usw)}$
        \For {$i \gets 0, 2sw, \ldots,  2sw(r-1)$}
            \State $p \gets 0$
            \For {$j \gets 0, 2sw, \ldots, l-2sw$}
                \For {$k \gets 0, w, \ldots, w(s-1)$}
                    \State $a_0 \gets \intify(K[i+j+k;w])$
                    \State $a_1 \gets \intify(K[i+j+k+sw;w])$
                    \State $b_0 \gets \intify(M[j+k;w])$
                    \State $b_1 \gets \intify(M[j+k+sw;w])$
                    \State $p \gets p + ((a_0 + b_0) \bmod 2^w)((a_1 + b_1) \bmod 2^w)$
                \EndFor
            \EndFor
            \State $h \gets h || \fromint_{2w}(p)$
        \EndFor
        \State $M \gets M[l;|M| - l]$
    \EndWhile
    \State \textbf{return} $h$
    \EndProcedure
\end{algorithmic}

On our target platform, this
is the largest $w$ with good support for a $\bin^w \times \bin^w \rightarrow \bin^{2w}$
multiply operation. The stride is the smallest which allows us to vectorize the hash
without rearranging data; a larger stride increases register pressure to no benefit. We choose
$r=4$ since we need $\epsilon = 2^{-wr} \leq 2^{-128}$, and $u = 64$ to get a compression ratio
of $2usw/2wr = 32$ and so minimize the work for the next hashing stage.

NH's speed comes with several inconvenient properties:
\begin{itemize}
    \item \cite{nh} shows that this function is $\epsilon$-almost-$\Delta$-universal, but this
        holds only over equal-length inputs
    \item $\epsilon = 2^{-wr}$, but the smallest nonempty output is $2wr$ bits, twice as large
        as necessary for this $\epsilon$ value
    \item The output size varies with the input size.
\end{itemize}
A second hashing stage is used to handle these issues.

\subsection{Adiantum hashing}

For Adiantum we use NH followed by Poly1305 to hash the message.
To avoid encoding and padding issues, we hash the message length and tweak with
a separate Poly1305 key.
In all this takes a $128 + 128 + 8576 = 8832$-bit key.

\begin{algorithmic}[0]
    \Procedure{H}{$K_H,T,M$}
    \State $K_T \gets K_H[0;128]$
    \State $K_M \gets K_H[128;128]$
    \State $K_N \gets K_H[256;8576]$
    \State $H_T \gets \Polydjb_{K_T}(\fromint_{128}(|M|) || T)$
    \State $H_M \gets \Polydjb_{K_M}(\NH_{K_N}(\pad_{128}(M)))$
    \State \textbf{return} $H_T \boxplus H_M$
    \EndProcedure
\end{algorithmic}

For distinct pairs $(T,M) \neq (T', M')$, we have that if $|M| \neq |M'|$ or $T \neq T'$,
then the $128 + |T|$-bit input to Poly1305 with key $K_T$ will differ.
Otherwise $|M| = |M'|$ but $M \neq M'$;
per \cite{nh} the probability NH will compress these to the same value is at most
$2^{-128}$. If they do not collide, the $256\ceil{|M|/8192}$-bit input to Poly1305 with key $K_M$
will differ. Since the sum of two $\epsilon$A$\Delta$U functions with independent keys is also
$\epsilon$A$\Delta$U, if for all queries $|T| \leq l_T$ and $|M| \leq l_M$ then
this composition is  $\epsilon$A$\Delta$U, with:

\begin{align*}
\epsilon &= 2^{-128} + 2^{-103}\ceil{\max(128 + l_T, 256\ceil{l_M/8192})/128}  \\
&= 2^{-128} + 2^{-103}\max(1 + \ceil{l_T/128}, 2\ceil{l_M/8192})
\end{align*}

If we limit our Adiantum attacker to at most $q$ queries each of which uses a tweak of length at
at most $l_T$ and a plaintext/ciphertext of length at most $l_P$, their distinguishing advantage
is therefore at most:

\begin{align*}
&( 2^{-126} + 2^{-103}\max(1 + \ceil{l_T/128}, 2\ceil{(l_P - 128)/8192}))\binom{q}{2} \\
+& \advantage{\pm \mathrm{prp}}{E_{K_E}}[(q, t')] \\
+& \advantage{\mathrm{prf}}{S_{K_S}}[(8832 + q(l_P - 128), t')] \\
\end{align*}

Version: \texttt{\input{work/git.tex}}
\end{document}
